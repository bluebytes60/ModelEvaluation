# Copyright (c) 2015, Turn Inc.
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#   
#   * Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
# 
# * Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
# 
# * Neither the name of ModelEvaluation nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
#          SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

compare_models <- function(data, models, parts, 
                           sig_level = 0.1, subgroup_analysis = TRUE, 
                           subgroup_thresh = c(0, 0.33, 0.66, 1), AA_test = FALSE){
  #The base function for compare models
  #
  #Args:
  # data:               The input data generated by compare_models.pig
  # models:             The two model numbers in order control, treatment ex: c(1, 2)
  # parts:              The number of parts analogous to ones used in compare_models.pig ex: c(90, 10)
  
  # sig_level:         Desired significance level
  #                     We use the first significance level for both margin and spend
  # subgroup_analysis:  Boolean indicating whether subgroup analysis is desired
  # subgroup_thresh:    The thresholds for subgroups including 0 and 1 ex:  c(0, 0.33, 0.66, 1)
  # AA_test:            Boolean indicating whether this is an AA-test. In this case, only the control
  #                      data will be considered.
  
  
  if(AA_test) {
    print(paste0("AA-test"));
    
    #proportionally designate the parts of the control model to the 
    #first and the second portions
    
    p1 = round(parts[1]*parts[1]/(sum(parts)));
    p2 = parts[1] - p1;
    
    changingparts <- sample(1:parts[1], p2);
    
    data <- data[which(data$model == models[1]),];
    
    
    data$model_id[is.element(data$part, changingparts)] <- models[2]; 
    parts = c(p1, p2);
  }
  
  M1 <- data[which(data$model == models[1]), ];
  M2 <- data[which(data$model == models[2]), ];
  
  if(nrow(M1) == 0) {
    stop("Model ", models[1], " does not exist in the data.");
  }
  if(nrow(M2) == 0) {
    stop("Model ", models[2], " does not exist in the data.");    
  }
  
  s <-list();
  if(subgroup_analysis) {
    d <- aggregate(data$spend, by=list(entity = data$entity), FUN=sum);
    names(d) <- c("entity", "spend");
    thresh <- subgroup_thresh;
    s <- subgroups(d, "spend", thresh);        
  }
  #ROI Analysis
  var <- c("value", "spend");
  roi_meta <- compare_models_for_measure(M1 = M1, 
                                         M2 = M2, 
                                         var = var, 
                                         importance_weights_type = 'uniform',
                                         min_num_impressions=100,
                                         parts = parts, 
                                         sig_level = sig_level , 
                                         subgroups = s,
                                         AA_test = AA_test);
  
  roip <- 1 - pnorm(abs(roi_meta$meta_summary$total_effect$z_effect));
  if(roip < sig_level/2) {
    print(paste0("ROI is significant with p-value=",roip));
    print(paste0("Estimated average increase:", 
                 roi_meta$meta_summary$total_effect$meta_effect_size_mean*
                   sqrt(roi_meta$meta_summary$total_effect$meta_effect_size_var)*100/
                   median(roi_meta$meta_summary$significance_analysis$mean1),"%"));
    
  }
  else {
    print(paste0("ROI is NOT significant with p-value=", roip));
  }
  print(paste0("ROI standard CI=[", roi_meta$meta_summary$total_effect$CI[1], ",",
               roi_meta$meta_summary$total_effect$CI[2], "]"));
  
  effect <- list(roi_meta);
  names(effect) <- c("roi_meta");
  
  return(effect);
}

compare_models_for_measure <- function(M1, M2, var, 
                                       importance_weights_type = 'uniform',
                                       min_num_impressions = 100,
                                       parts, sig_level, 
                                       subgroups, AA_test) {
  #Given a measure, this function applies the analysis
  #Args:
  # M1, M2:                   The data for the two models
  # var:                      The variables that are going to make the measure. var[1] goes
  #                           to numerator and  var[2] is the denomenator
  # importance_weights_type:  Two types are implemented:
  #                              uniform: 1 over all IOs
  #                              spend_base: convex weights based on the total spend of campaign
  # min_num_impressions:      Minuimum number of impressions in each PART
  #--The rest of the parameters are the same as compare_models
  
  sig_summary <- compare_models_per_campaign_significance(M1, M2, var, parts, min_num_impressions);
  if(sum(sig_summary$included)/length(sig_summary$included) < 0.3) {
    stop("Too few qualified entities. Make sure the number of parts input to
         compare_models matches the ones entered in the pig script.")
  }
  if(importance_weights_type == 'uniform') {
    importance_weights <- rep(1, 1, sum(sig_summary$included));
  }
  else {
    importance_weights <- sig_summary$totalSpend[which(sig_summary$included == TRUE)]/
      sum(sig_summary$totalSpend[which(sig_summary$included == TRUE)]);  
  }
  
  if(NROW(var) == 2) {
    isRate = TRUE;
  }
  else {
    isRate = FALSE
  }
  
  meta_summary <- meta_analysis(sig_summary, sig_level, importance_weights, isRate, 
                                AA_test, AA_qqplot = TRUE)
  
  if(NROW(subgroups) > 0) {
    meta_subgroup <- list();
    for(i in 1:(NROW(subgroups))) {
      if(importance_weights_type == 'uniform'){
        importance_weights <- rep(1, sum(sig_summary[which(sig_summary$campaign %in% subgroups[[i]]), "included"]));
      } 
      else {
        importance_weights <- sig_summary$totalSpend[which(sig_summary$included == TRUE &
                                                            sig_summary$campaign %in% subgroups[[i]])]/
          sum(sig_summary$totalSpend[which(sig_summary$included == TRUE &
                                            sig_summary$campaign %in% s[[i]])]);                  
      }
      meta_subgroup[[length(meta_subgroup) + 1]] <-  meta_analysis(
        sig_summary[which(sig_summary$campaign %in% subgroups[[i]]),], sig_level, 
        importance_weights, isRate, AA_test);
    }
    meta <- list(meta_summary, meta_subgroup);
    names(meta) <- c("meta_summary", "meta_subgroup");
  }
  else {
    meta <- list(meta_summary);
    names(meta) <- c("meta_summary");
  }
  
  return(meta);
  }
compare_models_per_campaign_significance <-
  function(M1, M2, var, parts, min_num_imps = 1000) {
    #Computes the statistics per campaign
    #
    #Args:
    # M1, M2: The data pertaining to the contrasting models
    # var:    The variables comprising the comparing statistics. Two  elements define a rate
    #         such that r=var[1]/var[2]
    # parts:  Parts in each model
    
    #Finding the common enities
    ents <- intersect(M1$entity, M2$entity);
    
    print(paste0("total common entities:", NROW(ents), " out of: ", NROW(union(M1$entity, M2$entity))));
    
    modelStats <- list(ents, rep(0, time=NROW(ents)), rep(0, time=NROW(ents)),
                       rep(0, time=NROW(ents)), rep(0, time=NROW(ents)), 
                       rep(0, time=NROW(ents)), rep(0, time=NROW(ents)),
                       rep(0, time=NROW(ents)), rep(FALSE, time=NROW(ents)), rep(0, time=NROW(ents)), 
                       rep(0, time=NROW(ents)), rep(0, time=NROW(ents)),
                       rep(0, time=NROW(ents)), rep(0, time=NROW(ents)), 
                       rep(0, time=NROW(ents)), rep(0, time=NROW(ents)),
                       rep(0, time=NROW(ents)), rep(0, time=NROW(ents)));
    names(modelStats) <- c("campaign", "totalSpend", "p1", "p2", "totalNum1", 
                           "totalNum2",  "totalDen1", "totalDen2", 
                           "included", "sp", "T", "d", "mean1", "mean2", "std1", "std2",
                           "avgImp1", "avgImp2");
    
    
    for(i in 1:NROW(ents)) {
      ent_parts1 <- M1[which(M1$entity == ents[i]), ];
      ent_parts2 <- M2[which(M2$entity == ents[i]), ];
      
      #The number of parts as enter to the function must exist
      if(nrow(ent_parts1) != parts[1] || nrow(ent_parts2) != parts[2]) {
        next;
        
      }
      
      modelStats$totalSpend[i]  <- sum(ent_parts1$spend) + sum(ent_parts2$spend);
      
      modelStats$totalNum1[i] <- sum(ent_parts1[, var[1]]);
      modelStats$totalNum2[i] <- sum(ent_parts2[, var[1]]);
      
      if(NROW(var) == 2) {
        modelStats$totalDen1[i] <- sum(ent_parts1[, var[2]]);
        modelStats$totalDen2[i] <- sum(ent_parts2[, var[2]]);
      }
      
      sufimp1 <- (ent_parts1[,"imps"] > min_num_imps);
      sufimp2 <- (ent_parts2[, "imps"] > min_num_imps);
      
      #If the number of qualified parts must be more than 90% 
      if(sum(sufimp1) > .9*parts[1] && sum(sufimp2) > .9*parts[2]){
        
        X1 <- ent_parts1[which(sufimp1 == TRUE), var[1]]; 
        X2 <- ent_parts2[which(sufimp2 == TRUE), var[1]]; 
        
        p1 <- sum(sufimp1);
        p2 <- sum(sufimp2);
        
        modelStats$p1[i] = p1;
        modelStats$p2[i] = p2;
        
        modelStats$avgImp1[i] <- mean(ent_parts1[which(sufimp1 == TRUE), "imps"]);
        modelStats$avgImp2[i] <- mean(ent_parts2[which(sufimp2 == TRUE), "imps"]);
        
        #Is this a rate?
        if(NROW(var) == 2) {
          X1 <- X1/ent_parts1[which(sufimp1 == TRUE), var[2]];
          X2 <- X2/ent_parts2[which(sufimp2 == TRUE), var[2]];
        }
        
        Sum_X <- vector();
        Sum_X2 <- vector();
        
        
        Sum_X[1] <- sum(X1);
        Sum_X[2] <- sum(X2);
        
        Sum_X2[1] <- sum(X1^2);
        Sum_X2[2] <- sum(X2^2);
        
        sp <- (Sum_X2[2]-(Sum_X[2]^2)/p2 + Sum_X2[1] - (Sum_X[1]^2)/p1 )/(sum(parts)-2);
        
        if(abs(sp)<1e-10)
          sp <- 0;
        modelStats$sp[i] <- sp;
                
        if(sp > 0.0001) {
          modelStats$included[i] <- TRUE;
             
          modelStats$T[i] <- (mean(X2) - mean(X1))/sqrt((p1+p2)/p1/p2*sp);
        }  
        modelStats$d[i] <- mean(X2) - mean(X1);
        modelStats$mean1[i] <- mean(X1);
        modelStats$mean2[i] <- mean(X2); 
        
        
        if(parts[1] > 1) {
          modelStats$std1[i] <- sd(X1);
        }
        if(parts[2] > 1) {
          modelStats$std2[i] <- sd(X2);
        }
        
      }
      
    }
    
    modelStats <- data.frame(modelStats);
    
    modelStats <- modelStats[order(-modelStats$totalSpend),]
    
    return(modelStats);
  }


meta_analysis <- function (sig_summary, sig_level, importance_weights, 
                           isStandard, AA_test = FALSE, AA_qqplot = FALSE) {
  #Implements the meta-analysis
  #
  #Args:
  # sig_summary:        The output of compare_models_per_campaign_significance.
  # sig_level:          The required significance level.
  # importance_weights: Importance weights applied only to the significance analysis.
  # isStandard:         Boolean whether this is a standard effect or not
  # AA_test:            Boolean whether this a AA-test
  # AA_qqplot           Boolean whether a qqplot, in case of an AA-test will be shown
  
  #Include only eligible capmaigns
  inc_sig_summary <- sig_summary[which(sig_summary$included == 
                                         TRUE), ]
  ns <- NROW(inc_sig_summary);
  
  ######Meta-Analysis###########
  
  if (isStandard) {
    #Standard effect size
    
    #Higgin's bias correction
    j <- 1 - 3/(4 * (max(inc_sig_summary$p1)+max(inc_sig_summary$p2)-2)  - 1)
    
    sum_parts <- inc_sig_summary$p1+inc_sig_summary$p2;
    prod_parts <- inc_sig_summary$p1*inc_sig_summary$p2;
    
    e <- inc_sig_summary$T * sqrt(sum_parts/prod_parts);
    #The effect
    d <- j * e;
    #The variance
    vd <- (j^2) * (sum_parts/prod_parts + (e^2)/(2 * sum_parts))
  }
  else {
    #Non-standard effect
    d <- inc_sig_summary$d;
    #Variance
    vd <- inc_sig_summary$std2^2/inc_sig_summary$p2 + inc_sig_summary$std1^2/inc_sig_summary$p1
  }
  
  wd <- 1/vd
  T <- sum(wd * d)/sum(wd)
  v <- 1/sum(wd)
  w <- sum(wd)
  
  #Cochran's Q
  Qu <- sum(wd * ((d - T)^2))
  if (Qu < NROW(wd) - 1) {
    #The summary mean will not be changed 
    print(paste0("fixed model.\n"))
    meta_effect_size_mean <- T
    meta_effect_size_var <- v
    tau2 <- 0
    Qs <- Qu
  }
  else {
    cs <- sum(wd) - sum(wd^2)/sum(wd)
    tau2 <- (Qu - (length(wd) - 1))/cs
    vs <- vd + tau2
    ws <- 1/vs
    meta_effect_size_mean <- sum(ws * d)/sum(ws)
    meta_effect_size_var <- 1/sum(ws)
    Qs <- sum(ws * ((d - meta_effect_size_mean)^2))
  }
  
  z_effect <- meta_effect_size_mean/sqrt(meta_effect_size_var)
  I2 <- max(c((Qu - (length(wd) - 1))/Qu * 100, 0));
  tau <- sqrt(tau2)
  hom_p <- pchisq(Qu, ns - 1)
  
  z_v = qnorm(1-sig_level/2);
  total_effect <- list(meta_effect_size_mean, meta_effect_size_var, 
                       z_effect, Qu, c(meta_effect_size_mean -  z_v * sqrt(meta_effect_size_var), 
                                       meta_effect_size_mean + z_v * sqrt(meta_effect_size_var)), 
                       c(meta_effect_size_mean - qt(sig_level/2, length(wd) - 2) * 
                           sqrt(meta_effect_size_var + tau2), meta_effect_size_mean + 
                           qt(sig_level/2, length(wd) - 2) * sqrt(meta_effect_size_var + 
                                                                    tau2)), sqrt(tau2), I2, hom_p, wd, d, vd, Qs)
  names(total_effect) <- list("meta_effect_size_mean", "meta_effect_size_var", 
                              "z_effect", "Q", "CI", "PI", "tau", "I2", "hom_p", "wd", 
                              "d", "vd", "Qs")
  
  #If the homogeneity is not rejected then no further analysis is required
  if(hom_p < .9) {
    print(paste0("homogenity could not be rejected."));
    hom_effect <- list();
    nonHom_effect <- list();
    effect <- list(total_effect, hom_effect, nonHom_effect, significance_analysis)
    names(effect) <- c("total_effect", "hom_effect", "nonHom_effect", "significance_analysis")
    
    return(effect);  
  }
  #Implementing the minimal heteregeneous set discovery algorithm
  
  wY2 <- sum(wd * (d^2))
  wY2s <- wd * (d^2)
  wY <- sum(wd * d)
  wYs <- wd^2
  
  idx <- rep(TRUE, ns);
  twd <- wd;
  
  midx <- which.max(wd*(d-T)^2);
  i <- ns;
  nQ <- Qu;
  
  while(i > 5 & 1-pchisq(nQ, i - 1) < .09) {
    wY2 <- wY2 - wd[midx]*(d[midx]^2);
    wY <- wY - wd[midx]*d[midx];
    w <- w - wd[midx];
    
    tT <- wY/w;
    #excluding from the homogenous set
    idx[midx] <- FALSE;
    twd[midx] <- 0;
    
    midx <- which.max(twd*((d-tT)^2));
    nQ <- wY2 - wY*wY/w;
    
    i <- i-1;
  } 
  
  hom_effect <- list();
  nonHom_effect <- list();
  
  if(i > 5) {
    hwd <- wd[idx];
    hd <- d[idx];
    hvd <- vd[idx];
    hc <- sum(hwd)-sum(hwd^2)/sum(hwd);
    htau2 <- max((nQ-(length(hwd)-1))/hc, 0);
    hvs <- hvd+htau2;
    hws <- 1/hvs;
    hmeta_effect_size_mean<-sum(hws*hd)/sum(hws);
    hmeta_effect_size_var <- 1/sum(hws);
    
    hom_effect <- list(idx, hmeta_effect_size_mean, hmeta_effect_size_var, 
                       hmeta_effect_size_mean/sqrt(hmeta_effect_size_var)
                       , nQ, c(hmeta_effect_size_mean - z_v * sqrt(hmeta_effect_size_var), 
                               hmeta_effect_size_mean + z_v * sqrt(hmeta_effect_size_var)), 
                       c(hmeta_effect_size_mean - qt(sig_level/2, length(hwd) - 2) * 
                           sqrt(hmeta_effect_size_var + htau2), hmeta_effect_size_mean + 
                           qt(sig_level/2, i - 2) * sqrt(hmeta_effect_size_var + 
                                                           htau2)), sqrt(htau2), (nQ-(i+1))/nQ*100,
                       pchisq(nQ, i - 1), wd, d, vd, sum(hwd*((hd-hmeta_effect_size_mean)^2)))
    names(hom_effect) <- list("idx", "meta_effect_size_mean", "meta_effect_size_var", 
                              "z_effect", "Q", "CI", "PI", "tau", "I2", "hom_p", "wd", 
                              "d", "vd", "Qs")
    
    idx <- !idx;
    nhwd <- wd[idx];
    nhd <- d[idx];
    nhvd <- vd[idx];
    nhc <- sum(nhwd)-sum(nhwd^2)/sum(nhwd);
    
    nhwY2 <- sum(nhwd*(nhd^2));
    nhwY <- sum(nhwd*nhd);
    nhw <- sum(nhwd);
    nhQ <- nhwY2-nhwY*nhwY/nhw;
    nhns <- length(nhwd)
    
    nhtau2 <- max((nhQ-(nhns-1))/nhc, 0);
    nhvs <- nhvd+nhtau2;
    nhws <- 1/nhvs;
    nhmeta_effect_size_mean<-sum(nhws*nhd)/sum(nhws);
    nhmeta_effect_size_var <- 1/sum(nhws);
    if(nhns < 3) {
      nonHom_effect <- list(idx, nhmeta_effect_size_mean, nhmeta_effect_size_var, nhmeta_effect_size_mean/sqrt(nhmeta_effect_size_var)
                            , nhQ, c(nhmeta_effect_size_mean - z_v * sqrt(nhmeta_effect_size_var), 
                                     nhmeta_effect_size_mean + z_v * sqrt(nhmeta_effect_size_var)),
                            c(0,0), sqrt(nhtau2), (nhQ-(nhns+1))/nhQ*100, 
                            pchisq(nhQ, i - 1), wd, d, vd, sum(nhwd*((nhd-nhmeta_effect_size_mean)^2)))                     
      
      
    }
    else {
      nonHom_effect <- list(idx, nhmeta_effect_size_mean, nhmeta_effect_size_var, 
                            nhmeta_effect_size_mean/sqrt(nhmeta_effect_size_var)
                            , nhQ, c(nhmeta_effect_size_mean - z_v * sqrt(nhmeta_effect_size_var), 
                                     nhmeta_effect_size_mean + z_v * sqrt(nhmeta_effect_size_var)), 
                            c(nhmeta_effect_size_mean - qt(sig_level/2, nhns - 2) * 
                                sqrt(nhmeta_effect_size_var + nhtau2), nhmeta_effect_size_mean + 
                                qt(sig_level/2, nhns - 2) * sqrt(nhmeta_effect_size_var + 
                                                                   nhtau2)), sqrt(nhtau2), (nhQ-(nhns+1))/nhQ*100,
                            pchisq(nhQ, i - 1), wd, d, vd, sum(nhwd*((nhd-nhmeta_effect_size_mean)^2)))
    }
    names(nonHom_effect) <- list("idx", "meta_effect_size_mean", "meta_effect_size_var", 
                                 "z_effect", "Q", "CI", "PI", "tau", "I2", "hom_p", "wd", 
                                 "d", "vd", "Qs")   
  }
  
  
  effect <- list(total_effect, inc_sig_summary, hom_effect, nonHom_effect)
  names(effect) <- c("total_effect", "significance_analysis", "hom_effect", "nonHom_effect")
  return(effect)
}                         

subgroups <- function(data, cols, thresh) {
  data <- data[order(data[,cols]), ];
  cmsm <- cumsum(data[,cols ])/sum(data[,cols]);
  subgroups <- list();
  for(i in 2:NROW(thresh)) {   
    subgroups <- c(subgroups, list(data[which(cmsm > thresh[i-1] & cmsm < thresh[i]),"entity"]));
  }
  
  return(subgroups);
}

printEffect <- function(Name, meta_summary, meta_subgroup = NULL ) {
  dashed_line <- "----------------------------------";
  m <- sprintf("%s ANALYSIS
               %s
               Total Analysis
               %s
               Included # of campaigns=%i
               Mean effect confidence interval=[%2f,%2f]
               Z-score of mean effect=%2f
               Q=%2f
               I^2=%2f
               %s
               Subgroup Analysis
               %s", Name, dashed_line, dashed_line, 
               length(meta_summary$significance_analysis$campaign),
               meta_summary$total_effect$CI[1], 
               meta_summary$total_effect$CI[2],
               meta_summary$total_effect$z_effect,
               meta_summary$total_effect$Q,
               meta_summary$total_effect$I2, dashed_line, dashed_line);
  m2 <- sprintf("
                  Homogeneous group
               %s
                Included # of IOs=%i
                Mean effect confidence interval=[%2f,%2f]
                Z-score of mean effect=%2f
                Q=%2f
                I^2=%2f
                %s
                Non-Homogeneous group
                %s
                Included # of IOs=%i
                Mean effect confidence interval=[%2f,%2f]
                Z-score of mean effect=%2f
                Q=%2f
                I^2=%2f
                %s", dashed_line, sum(meta_summary$hom_effect$idx),
                meta_summary$hom_effect$CI[1],
                meta_summary$hom_effect$CI[2],
                meta_summary$hom_effect$z_effect,
                meta_summary$hom_effect$Q,
                meta_summary$hom_effect$I2,dashed_line, dashed_line,
                sum(meta_summary$nonHom_effect$idx),
                meta_summary$nonHom_effect$CI[1],
                meta_summary$nonHom_effect$CI[2],
                meta_summary$nonHom_effect$z_effect,
                meta_summary$nonHom_effect$Q,
                meta_summary$nonHom_effect$I2,dashed_line);   
  m <- paste0(m, m2);
  
  if(!is.null(meta_subgroup)) {
    Qwithin <- 0;
    for(i in 1:length(meta_subgroup)) {
      m2 <- sprintf("
                    Subgroup %i
                    %s
                    Included # of campaigns=%i
                    Mean effect confidence interval=[%2f,%2f]
                    Z-score of mean effect=%2f
                    Q=%2f
                    I^2=%2f
                    %s", i, dashed_line, 
                    length(meta_subgroup[[i]]$significance_analysis$campaign),
                    meta_subgroup[[i]]$total_effect$CI[1], 
                    meta_subgroup[[i]]$total_effect$CI[2], 
                    meta_subgroup[[i]]$total_effect$z_effect, 
                    meta_subgroup[[i]]$total_effect$Q, 
                    meta_subgroup[[i]]$total_effect$I2, dashed_line);
      
      Qwithin <- Qwithin + meta_subgroup[[i]]$total_effect$Qs;
      m <- paste0(m, m2);
    }
    Qbetween <- meta_summary$total_effect$Qs - Qwithin;
    m2 <- sprintf("
                  Overal subgroup analysis
                  %s
                  Qwithin=%2f
                  Qbetween=%2f
                  Membership significance=%2f", dashed_line,
                  Qwithin,
                  max(c(Qbetween,0)),
                  pchisq(Qbetween, length(meta_subgroup) - 1));
    m <- paste0(m, m2);
  }
  return(m); 
}
library("gap")
models <- c(419, 392);
parts <- c(40,5);
data <- read.csv('sample_data_2.tsv', header = T, sep='\t');


effect <- compare_models(data, models, parts, subgroup_analysis = TRUE, AA_test = FALSE)

message( printEffect("ROI", 
                     effect$roi_meta$meta_summary, 
                     effect$roi_meta$meta_subgroup));



